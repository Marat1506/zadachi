# Подготовка к вступительному экзамену в магистратуру по направлению Информатика и вычислительная техника

## Типовые вопросы и подробные ответы

В данном документе представлены ответы на типовые вопросы и решения задач, которые могут встретиться на вступительном экзамене в магистратуру по направлению «Информатика и вычислительная техника». Материалы основаны на анализе предоставленного файла с примерами формулировок вопросов.

### 1. Языки программирования высокого уровня

**Вопрос:** К языкам программирования высокого уровня относятся ...

**Ответ:** Языки программирования высокого уровня (ЯВУ) — это языки, разработанные для упрощения процесса написания программ, абстрагируясь от деталей аппаратной архитектуры компьютера. Они используют синтаксис, близкий к естественному языку, и предоставляют мощные абстракции, такие как переменные, функции, объекты и структуры данных. Это позволяет программистам сосредоточиться на логике задачи, а не на управлении памятью или регистрами процессора. Программы, написанные на ЯВУ, обычно требуют компиляции или интерпретации для выполнения на компьютере.

Примеры языков программирования высокого уровня включают:

*   **Python:** Интерпретируемый, высокоуровневый язык общего назначения с динамической типизацией. Широко используется в веб-разработке, анализе данных, машинном обучении и автоматизации.
*   **Java:** Объектно-ориентированный язык, компилируемый в байт-код, который выполняется на виртуальной машине Java (JVM). Известен своей кроссплатформенностью и используется для корпоративных приложений, мобильной разработки (Android) и больших систем.
*   **C++:** Компилируемый, статически типизированный язык, являющийся расширением языка C. Поддерживает процедурное, объектно-ориентированное и обобщенное программирование. Используется для системного программирования, разработки игр, высокопроизводительных приложений.
*   **C#:** Объектно-ориентированный язык, разработанный Microsoft, часть платформы .NET. Используется для разработки настольных приложений (Windows), веб-приложений (ASP.NET) и игр (Unity).
*   **JavaScript:** Интерпретируемый язык сценариев, в основном используемый для клиентской веб-разработки (интерактивные веб-страницы). С появлением Node.js также активно применяется на стороне сервера.
*   **PHP:** Язык сценариев, ориентированный на веб-разработку на стороне сервера. Широко используется для создания динамических веб-сайтов и веб-приложений.
*   **Ruby:** Динамический, объектно-ориентированный язык общего назначения, известный своей простотой и элегантностью. Популярен в веб-разработке (фреймворк Ruby on Rails).
*   **Swift:** Разработан Apple для создания приложений под iOS, macOS, watchOS и tvOS. Современный, безопасный и производительный язык.
*   **Go (Golang):** Разработан Google, статически типизированный, компилируемый язык. Отличается высокой производительностью, эффективным управлением параллелизмом и простотой синтаксиса. Используется для системного программирования, сетевых сервисов, облачных приложений.

### 2. Динамические языки программирования

**Вопрос:** Динамическим языком программирования называется язык, который…

**Ответ:** Динамическим языком программирования называется язык, в котором большая часть проверок типов и других операций, обычно выполняемых на этапе компиляции (статические языки), откладывается до времени выполнения (runtime). Это предоставляет большую гибкость, но может привести к обнаружению ошибок только во время выполнения программы.

Ключевые характеристики динамических языков программирования:

*   **Динамическая типизация:** Тип переменной определяется во время выполнения, а не на этапе компиляции. Одна и та же переменная может хранить значения разных типов в разное время. Например, в Python `x = 10` (целое число), затем `x = 

"hello"` (строка) — это допустимо.
*   **Позднее связывание (Late Binding):** Вызов методов и функций разрешается во время выполнения, а не на этапе компиляции. Это позволяет изменять поведение программы динамически.
*   **Рефлексия:** Возможность программы исследовать и модифицировать свою собственную структуру и поведение во время выполнения. Например, получать информацию о типах объектов, вызывать методы по имени строки.
*   **Динамическая генерация кода:** Некоторые динамические языки позволяют генерировать и выполнять новый код во время работы программы.
*   **Гибкость и быстрая разработка:** Динамические языки часто используются для быстрой прототипизации и разработки благодаря своей гибкости и отсутствию строгих требований к предварительному объявлению типов.

Примеры динамических языков программирования:

*   **Python**
*   **JavaScript**
*   **Ruby**
*   **PHP**
*   **Perl**
*   **Lisp**

Несмотря на гибкость, динамические языки могут быть менее производительными по сравнению со статически типизированными языками из-за накладных расходов на проверки типов во время выполнения. Также ошибки, связанные с типами, могут быть обнаружены только на поздних стадиях разработки или даже в продакшене.

### 3. Базовые алгоритмические структуры

**Вопрос:** К базовым алгоритмическим структурам относятся ...

**Ответ:** Базовые алгоритмические структуры (или управляющие структуры) — это фундаментальные конструкции, используемые для построения любых алгоритмов. Теорема Бёма-Якопини (или теорема о структурном программировании) утверждает, что любая вычислимая функция может быть реализована с использованием только трех базовых управляющих структур: **последовательности**, **ветвления** и **цикла**.

1.  **Последовательность (Sequence):**
    *   Это самая простая структура, представляющая собой выполнение инструкций одна за другой в том порядке, в котором они записаны. Каждая инструкция выполняется ровно один раз, и управление передается следующей инструкции после завершения текущей.
    *   Пример: `инструкция_1; инструкция_2; инструкция_3;`

2.  **Ветвление (Selection / Conditional / Choice):**
    *   Эта структура позволяет алгоритму принимать решения и выполнять различные блоки инструкций в зависимости от истинности или ложности некоторого условия. Существуют две основные формы ветвления:
        *   **Если-то (If-Then):** Выполняет блок инструкций, если условие истинно. Если условие ложно, блок пропускается.
            *   Пример: `ЕСЛИ условие ТО инструкция_1;`
        *   **Если-то-иначе (If-Then-Else):** Выполняет один блок инструкций, если условие истинно, и другой блок, если условие ложно.
            *   Пример: `ЕСЛИ условие ТО инструкция_1 ИНАЧЕ инструкция_2;`
        *   Множественное ветвление (например, `switch-case` или `elif` в Python) является расширением базовой структуры ветвления.

3.  **Цикл (Iteration / Loop / Repetition):**
    *   Эта структура позволяет многократно выполнять один и тот же блок инструкций до тех пор, пока не будет выполнено определенное условие. Существуют различные типы циклов:
        *   **Цикл с предусловием (While loop):** Условие проверяется перед каждой итерацией. Блок инструкций выполняется, пока условие истинно. Если условие изначально ложно, блок не выполнится ни разу.
            *   Пример: `ПОКА условие ДЕЛАТЬ инструкция_1;`
        *   **Цикл с постусловием (Do-While loop):** Блок инструкций выполняется хотя бы один раз, а затем условие проверяется после каждой итерации. Цикл продолжается, пока условие истинно.
            *   Пример: `ДЕЛАТЬ инструкция_1 ПОКА условие;`
        *   **Цикл со счетчиком (For loop):** Используется, когда количество итераций известно заранее. Включает инициализацию счетчика, условие продолжения и изменение счетчика на каждой итерации.
            *   Пример: `ДЛЯ каждого элемента в коллекции ДЕЛАТЬ инструкция_1;`

Эти три базовые структуры являются достаточными для построения любого алгоритма, что делает их краеугольным камнем структурного программирования и основой для разработки логики программ.



### 4. Теория принятия решений (ТПР)

**Вопрос:** Выраженное каким-либо образом личное суждение о.... [продолжение формулировки понятия из области ТПР] Дать короткую формулировку ответа

**Ответ:** В теории принятия решений (ТПР) личное суждение, выраженное в количественной или качественной форме, называется **предпочтением**. Предпочтения отражают субъективные оценки лицом, принимающим решение (ЛПР), относительно различных альтернатив или исходов. Они являются основой для выбора наилучшего варианта действий в условиях неопределенности или многокритериальности.

### 5. 3D-графика: Проекции

**Вопрос:** Какая проекция позволяет получить ... [продолжение формулировки] 3D объекта?

**Ответ:** В 3D-графике для получения двумерного изображения трехмерного объекта используются различные типы проекций. Основные из них — **перспективная** и **ортографическая**.

*   **Перспективная проекция (Perspective Projection):**
    *   Имитирует человеческое зрение, создавая иллюзию глубины и расстояния. Объекты, расположенные дальше от наблюдателя, кажутся меньше, а параллельные линии сходятся в одной точке на горизонте (точке схода).
    *   Используется в большинстве реалистичных 3D-приложений, таких как игры, симуляторы, архитектурная визуализация.

*   **Ортографическая (ортогональная) проекция (Orthographic Projection):**
    *   Проецирует точки объекта на плоскость проекции по параллельным линиям, перпендикулярным этой плоскости. В результате сохраняются реальные размеры и пропорции объекта, независимо от его удаленности от наблюдателя. Параллельные линии остаются параллельными.
    *   Используется в инженерных и чертежных приложениях (например, САПР), где важна точность размеров и пропорций. Виды спереди, сбоку и сверху являются примерами ортографических проекций.

В зависимости от формулировки вопроса, ответ может быть одним из этих двух типов проекций или их разновидностей (например, аксонометрическая проекция как подвид ортографической).

### 6. Теория баз данных (БД)

**Вопрос:** [начало формулировки - термин]... в теории БД называют:

**Ответ:** Этот вопрос требует знания основных терминов реляционной теории баз данных. В зависимости от формулировки, это могут быть такие понятия, как:

*   **Отношение (Relation):** Таблица, состоящая из строк и столбцов.
*   **Кортеж (Tuple):** Строка в таблице, представляющая одну запись.
*   **Атрибут (Attribute):** Столбец в таблице, определяющий свойство сущности.
*   **Домен (Domain):** Множество допустимых значений для атрибута.
*   **Ключ (Key):** Атрибут или набор атрибутов, уникально идентифицирующий кортеж в отношении. Различают первичные, потенциальные, внешние ключи.
*   **Нормализация:** Процесс организации данных в базе данных для минимизации избыточности и улучшения целостности данных. Включает приведение таблиц к нормальным формам (1НФ, 2НФ, 3НФ и т.д.).
*   **Транзакция:** Последовательность операций с базой данных, которая рассматривается как единое целое. Обладает свойствами ACID (атомарность, согласованность, изолированность, долговечность).

### 7. Компьютерные сети: Преобразование сетевых адресов

**Вопрос:** Какой протокол используется для преобразования [указано преобразование сетевых адресов] ?

**Ответ:** В зависимости от типа преобразования, могут использоваться следующие протоколы:

*   **NAT (Network Address Translation):** Протокол для преобразования частных (локальных) IP-адресов в публичные (глобальные) и обратно. Позволяет множеству устройств в локальной сети использовать один публичный IP-адрес для доступа в Интернет.
*   **ARP (Address Resolution Protocol):** Протокол для преобразования IP-адреса (логического адреса) в MAC-адрес (физический адрес) в локальной сети. Используется для определения физического адреса устройства по его IP-адресу.
*   **RARP (Reverse Address Resolution Protocol):** Обратный ARP, позволяет устройству определить свой IP-адрес по известному MAC-адресу. В настоящее время вытеснен более современными протоколами, такими как BOOTP и DHCP.
*   **DNS (Domain Name System):** Система для преобразования доменных имен (например, `google.com`) в IP-адреса и обратно. Позволяет пользователям использовать легко запоминаемые имена вместо числовых IP-адресов.

### 8. Модель OSI: Уровни и оборудование

**Вопрос:** На каком уровне модели OSI работает [указано сетевое оборудование ]?

**Ответ:** Модель OSI (Open Systems Interconnection) делит сетевое взаимодействие на 7 уровней. Сетевое оборудование работает на разных уровнях:

*   **Уровень 1 (Физический):**
    *   **Оборудование:** Концентраторы (Hubs), повторители (Repeaters), кабели, разъемы.
    *   **Функции:** Передача битов по физической среде.
*   **Уровень 2 (Канальный):**
    *   **Оборудование:** Коммутаторы (Switches), мосты (Bridges), сетевые карты (NIC).
    *   **Функции:** Адресация на основе MAC-адресов, обнаружение и исправление ошибок на физическом уровне, управление потоком данных.
*   **Уровень 3 (Сетевой):**
    *   **Оборудование:** Маршрутизаторы (Routers), многоуровневые коммутаторы (Layer 3 Switches).
    *   **Функции:** Маршрутизация пакетов между сетями на основе IP-адресов, логическая адресация.
*   **Уровень 4 (Транспортный):**
    *   **Оборудование:** Межсетевые экраны (Firewalls) с отслеживанием состояния.
    *   **Функции:** Обеспечение надежной доставки данных (TCP) или быстрой доставки без гарантий (UDP), сегментация данных.
*   **Уровни 5-7 (Сеансовый, Представления, Прикладной):**
    *   **Оборудование:** Шлюзы (Gateways), прокси-серверы (Proxy Servers), межсетевые экраны прикладного уровня.
    *   **Функции:** Управление сеансами, преобразование форматов данных, предоставление сетевых служб приложениям.

### 9. IP-адресация: Классы

**Вопрос:** К какому классу относится IP-адрес [указан IP адрес]?

**Ответ:** В классовой IP-адресации (IPv4) адреса делятся на классы в зависимости от значения первого октета:

*   **Класс A:**
    *   **Диапазон:** 1.0.0.0 – 126.255.255.255
    *   **Первый октет:** 1-126 (0xxxxxxx в двоичном виде)
    *   **Маска подсети по умолчанию:** 255.0.0.0 (/8)
    *   **Назначение:** Для очень крупных сетей.
*   **Класс B:**
    *   **Диапазон:** 128.0.0.0 – 191.255.255.255
    *   **Первый октет:** 128-191 (10xxxxxx в двоичном виде)
    *   **Маска подсети по умолчанию:** 255.255.0.0 (/16)
    *   **Назначение:** Для сетей среднего размера.
*   **Класс C:**
    *   **Диапазон:** 192.0.0.0 – 223.255.255.255
    *   **Первый октет:** 192-223 (110xxxxx в двоичном виде)
    *   **Маска подсети по умолчанию:** 255.255.255.0 (/24)
    *   **Назначение:** Для небольших сетей.
*   **Класс D:**
    *   **Диапазон:** 224.0.0.0 – 239.255.255.255
    *   **Первый октет:** 224-239 (1110xxxx в двоичном виде)
    *   **Назначение:** Для многоадресной (multicast) рассылки.
*   **Класс E:**
    *   **Диапазон:** 240.0.0.0 – 255.255.255.255
    *   **Первый октет:** 240-255 (1111xxxx в двоичном виде)
    *   **Назначение:** Зарезервирован для экспериментальных целей.

**Примечание:** Адрес 127.0.0.1 является адресом обратной петли (loopback) и используется для тестирования сетевого стека на локальном хосте.

### 10. Маршрутизируемые протоколы

**Вопрос:** Какой из протоколов является маршрутизируемым?

**Ответ:** Маршрутизируемый протокол — это сетевой протокол, который предоставляет информацию, достаточную для того, чтобы пакеты могли быть перенаправлены (маршрутизированы) от одной сети к другой. Для этого протокол должен содержать адреса источника и назначения, которые уникальны в рамках всей объединенной сети (интерсети).

Примеры маршрутизируемых протоколов:

*   **IP (Internet Protocol):** Основной протокол сетевого уровня в стеке TCP/IP, на котором построен Интернет. Является самым распространенным маршрутизируемым протоколом.
*   **IPX (Internetwork Packet Exchange):** Протокол, разработанный Novell для сетей NetWare. В настоящее время практически не используется.
*   **AppleTalk:** Протокол, разработанный Apple для своих сетей. Также устарел.

Немаршрутизируемые протоколы, такие как **NetBEUI**, могут работать только в пределах одного сегмента локальной сети, поскольку они не содержат информации, необходимой для маршрутизации пакетов между сетями.

### 11. Объектно-ориентированное программирование (ООП) в C++

**Вопрос:** Вопрос про реализацию ООП в С++

**Ответ:** C++ является одним из классических языков, поддерживающих объектно-ориентированное программирование. Основные концепции ООП в C++:

*   **Классы и объекты:**
    *   **Класс (Class):** Шаблон для создания объектов, определяющий их свойства (поля, атрибуты) и поведение (методы). В C++ класс определяется с помощью ключевого слова `class`.
    *   **Объект (Object):** Экземпляр класса, созданный по его шаблону.
*   **Инкапсуляция (Encapsulation):**
    *   Объединение данных и методов, работающих с этими данными, в одном классе. Доступ к данным ограничивается с помощью спецификаторов доступа: `public` (открытый), `protected` (защищенный), `private` (закрытый). Это позволяет скрыть детали реализации и защитить данные от несанкционированного доступа.
*   **Наследование (Inheritance):**
    *   Механизм, позволяющий создавать новые классы (производные, дочерние) на основе существующих (базовых, родительских). Производный класс наследует свойства и методы базового класса и может добавлять свои собственные или переопределять унаследованные. В C++ поддерживается множественное наследование (класс может иметь несколько базовых классов).
*   **Полиморфизм (Polymorphism):**
    *   Способность объектов разных классов отвечать на один и тот же вызов метода по-разному. В C++ полиморфизм реализуется через:
        *   **Перегрузку функций и операторов (Overloading):** Создание нескольких функций или операторов с одинаковым именем, но разными параметрами.
        *   **Виртуальные функции (Virtual Functions):** Механизм, позволяющий в производном классе переопределить метод базового класса. Вызов конкретной реализации метода определяется во время выполнения (динамический полиморфизм) на основе фактического типа объекта.
*   **Абстракция (Abstraction):**
    *   Выделение наиболее значимых характеристик объекта и игнорирование второстепенных. В C++ абстракция реализуется через абстрактные классы (классы, содержащие хотя бы одну чисто виртуальную функцию) и интерфейсы.

### 12. Архитектуры процессоров: Гарвардская и фон-Неймановская

**Вопрос:** Гарвардская архитектура отличается от фон-Неймановской ...

**Ответ:** Основное отличие между Гарвардской и фон-Неймановской архитектурами заключается в **способе хранения и доступа к инструкциям (программам) и данным**.

*   **Архитектура фон-Неймана (Von Neumann Architecture):**
    *   **Общая память:** Инструкции и данные хранятся в одной и той же памяти.
    *   **Общая шина:** Используется одна и та же шина для доступа как к инструкциям, так и к данным.
    *   **Последовательный доступ:** Процессор не может одновременно считывать инструкцию и данные, так как они используют общую шину. Это создает «узкое место фон-Неймана» (Von Neumann bottleneck), ограничивающее производительность.
    *   **Применение:** Большинство современных компьютеров общего назначения (настольные ПК, серверы) основаны на модифицированной фон-Неймановской архитектуре.

*   **Гарвардская архитектура (Harvard Architecture):**
    *   **Раздельная память:** Инструкции и данные хранятся в отдельных физических устройствах памяти.
    *   **Раздельные шины:** Используются отдельные шины для доступа к памяти инструкций и памяти данных.
    *   **Параллельный доступ:** Процессор может одновременно считывать инструкцию из памяти инструкций и данные из памяти данных, что повышает производительность.
    *   **Применение:** Широко используется в микроконтроллерах, цифровых сигнальных процессорах (DSP) и в кэш-памяти современных процессоров (раздельные кэши для инструкций и данных).

**Ключевое отличие:** Гарвардская архитектура имеет **раздельную память и шины для инструкций и данных**, в то время как фон-Неймановская использует **общую память и шину**.

### 13. Постановка задачи оптимизации: Начальный этап

**Вопрос:** С какого этапа начинается постановка задачи оптимизации ?

**Ответ:** Постановка задачи оптимизации начинается с этапа **определения целевой функции (критерия оптимальности)**. Целевая функция — это математическое выражение, которое необходимо максимизировать или минимизировать. Она количественно описывает цель, которую мы хотим достичь.

Например, если мы хотим минимизировать затраты на производство, целевой функцией будет функция, описывающая эти затраты. Если мы хотим максимизировать прибыль, целевой функцией будет функция прибыли.

После определения целевой функции следуют другие этапы, такие как определение управляемых переменных и ограничений.

### 14. Постановка задачи оптимизации: Заключительный этап

**Вопрос:** Какой этап – заключительный при постановке задачи оптимизации?

**Ответ:** Заключительным этапом при **постановке** задачи оптимизации является **определение ограничений**. Ограничения — это условия, которым должны удовлетворять управляемые переменные. Они могут быть выражены в виде равенств или неравенств и отражают физические, экономические или другие ограничения реальной системы.

После того как определены целевая функция, управляемые переменные и ограничения, математическая модель задачи оптимизации считается сформулированной, и можно переходить к этапу ее решения с помощью соответствующих методов.

### 15. HTML: Теги

**Вопрос:** [Указан тег] в HTML позволяет задать

**Ответ:** Этот вопрос требует знания конкретных тегов HTML и их назначения. Например:

*   **`<a>`:** Создает гиперссылку.
*   **`<img>`:** Вставляет изображение.
*   **`<div>`:** Определяет блочный элемент-контейнер для группировки других элементов.
*   **`<span>`:** Определяет строчный элемент-контейнер.
*   **`<p>`:** Определяет абзац текста.
*   **`<h1>` - `<h6>`:** Определяют заголовки разных уровней.
*   **`<ul>`, `<ol>`, `<li>`:** Создают маркированные и нумерованные списки.
*   **`<table>`, `<tr>`, `<td>`, `<th>`:** Создают таблицы.
*   **`<form>`, `<input>`, `<button>`:** Создают формы для ввода данных.

### 16. Алгоритмы шифрования

**Вопрос:** Какие алгоритмы могут применяться для шифрования?

**Ответ:** Алгоритмы шифрования делятся на две основные категории: **симметричные** и **асимметричные**.

*   **Симметричные алгоритмы (шифрование с секретным ключом):**
    *   Используют один и тот же ключ как для шифрования, так и для расшифровки. Ключ должен быть известен обеим сторонам и храниться в секрете.
    *   **Преимущества:** Высокая скорость работы.
    *   **Недостатки:** Проблема безопасной передачи ключа.
    *   **Примеры:**
        *   **AES (Advanced Encryption Standard):** Современный стандарт симметричного шифрования, широко используется во всем мире.
        *   **DES (Data Encryption Standard):** Устаревший стандарт, уязвимый для современных атак.
        *   **3DES (Triple DES):** Усиленная версия DES, применяющая алгоритм трижды. Считается надежным, но медленным.
        *   **Blowfish, Twofish:** Быстрые и надежные алгоритмы.
        *   **ГОСТ 28147-89:** Российский стандарт симметричного шифрования.

*   **Асимметричные алгоритмы (шифрование с открытым ключом):**
    *   Используют пару ключей: **открытый (public)** и **закрытый (private)**. Открытый ключ свободно распространяется и используется для шифрования данных. Закрытый ключ хранится в секрете и используется для расшифровки данных, зашифрованных соответствующим открытым ключом.
    *   **Преимущества:** Решают проблему передачи ключа, используются для создания цифровых подписей.
    *   **Недостатки:** Значительно медленнее симметричных алгоритмов.
    *   **Примеры:**
        *   **RSA (Rivest-Shamir-Adleman):** Один из самых первых и наиболее известных асимметричных алгоритмов.
        *   **DSA (Digital Signature Algorithm):** Алгоритм для создания цифровых подписей.
        *   **Алгоритмы на основе эллиптических кривых (ECC - Elliptic Curve Cryptography):** Обеспечивают тот же уровень безопасности, что и RSA, но с меньшей длиной ключа, что делает их более эффективными.

Также существуют **хеш-функции**, которые не являются алгоритмами шифрования в строгом смысле, но играют важную роль в криптографии. Они преобразуют данные произвольной длины в строку фиксированной длины (хеш-сумму) и являются необратимыми. Примеры: **MD5, SHA-1, SHA-256**.

### 17. Теория принятия решений: Лицо, принимающее решение (ЛПР)

**Вопрос:** Что определяет лицо, принимающее решение?

**Ответ:** Лицо, принимающее решение (ЛПР), в теории принятия решений определяет следующие ключевые элементы:

*   **Цели и задачи:** ЛПР формулирует цели, которые необходимо достичь, и задачи, которые нужно решить.
*   **Альтернативы:** ЛПР определяет множество возможных вариантов действий (альтернатив), из которых будет осуществляться выбор.
*   **Критерии оценки:** ЛПР устанавливает критерии, по которым будут оцениваться и сравниваться альтернативы. Критерии могут быть количественными (например, стоимость, прибыль) или качественными (например, удобство, надежность).
*   **Предпочтения:** ЛПР выражает свои субъективные предпочтения относительно важности различных критериев и привлекательности различных исходов.
*   **Окончательный выбор:** На основе анализа альтернатив по заданным критериям и с учетом своих предпочтений, ЛПР делает окончательный выбор наилучшей альтернативы.

### 18. Модель OSI: Протоколы по уровням

**Вопрос:** Какой из протоколов является протоколом [заданного] уровня модели OSI?

**Ответ:** Этот вопрос требует соотнесения протоколов с уровнями модели OSI:

*   **Уровень 7 (Прикладной):** HTTP, FTP, SMTP, DNS, Telnet, SSH
*   **Уровень 6 (Представления):** SSL/TLS, JPEG, MPEG, ASCII
*   **Уровень 5 (Сеансовый):** NetBIOS, RPC, PPTP
*   **Уровень 4 (Транспортный):** TCP, UDP
*   **Уровень 3 (Сетевой):** IP, ICMP, IGMP, OSPF, RIP
*   **Уровень 2 (Канальный):** Ethernet, PPP, ARP, Frame Relay
*   **Уровень 1 (Физический):** Bluetooth, USB, Ethernet (физический уровень)

### 19. Модель OSI: Блоки данных

**Вопрос:** Укажите наименование блока данных [заданного] уровня модели OSI?

**Ответ:** На каждом уровне модели OSI блок данных имеет свое название (Protocol Data Unit - PDU):

*   **Уровни 5-7 (Прикладной, Представления, Сеансовый):** Данные (Data) или Сообщение (Message)
*   **Уровень 4 (Транспортный):** Сегмент (Segment) для TCP, Дейтаграмма (Datagram) для UDP
*   **Уровень 3 (Сетевой):** Пакет (Packet)
*   **Уровень 2 (Канальный):** Кадр (Frame)
*   **Уровень 1 (Физический):** Бит (Bit)

### 20. Методы оптимизации: Пассивная стратегия поиска

**Вопрос:** Что такое пассивная стратегия поиска при численном решении задач [задан вариант] оптимизации?

**Ответ:** Пассивная стратегия поиска в методах одномерной оптимизации заключается в том, что все точки, в которых будет вычисляться значение целевой функции, **определяются заранее, до начала вычислений**. Эти точки обычно располагаются равномерно на заданном интервале неопределенности.

Примером метода, использующего пассивную стратегию, является **метод перебора (или метод полного перебора)**. Его недостатком является низкая эффективность, так как он требует большого количества вычислений функции, особенно при высокой требуемой точности. Он не использует информацию, полученную на предыдущих шагах, для выбора следующих точек.

### 21. Методы оптимизации: Наиболее частая стратегия поиска

**Вопрос:** Какая стратегия поиска наиболее часто применяется при численном решении задач [задан вариант] оптимизации?

**Ответ:** Наиболее часто при численном решении задач оптимизации (особенно одномерной) применяется **последовательная (или адаптивная) стратегия поиска**. В отличие от пассивной стратегии, здесь точки, в которых вычисляется целевая функция, выбираются последовательно, одна за другой. При этом выбор каждой следующей точки **зависит от результатов вычислений в предыдущих точках**.

Эта стратегия позволяет значительно сократить количество вычислений, так как на каждом шаге интервал неопределенности, содержащий оптимум, сужается. Примеры методов, использующих последовательную стратегию:

*   **Метод дихотомии (деления отрезка пополам)**
*   **Метод золотого сечения**
*   **Метод Фибоначчи**
*   **Градиентные методы**

### 22. Теория принятия решений: Критерии

**Вопрос:** Принятие решения по [заданному] критерию …

**Ответ:** Этот вопрос касается различных критериев принятия решений в условиях неопределенности, когда вероятности исходов неизвестны. Основные критерии:

*   **Критерий Вальда (максиминный):** Критерий крайнего пессимизма. Выбирается альтернатива, которая максимизирует минимальный возможный выигрыш. `max(min(a_ij))`
*   **Максимаксный критерий:** Критерий крайнего оптимизма. Выбирается альтернатива, которая максимизирует максимальный возможный выигрыш. `max(max(a_ij))`
*   **Критерий Гурвица (критерий оптимизма-пессимизма):** Компромисс между критериями Вальда и максимаксным. Выбирается альтернатива, максимизирующая взвешенную сумму минимального и максимального выигрышей. `max(α * max(a_ij) + (1-α) * min(a_ij))`, где `α` — коэффициент оптимизма.
*   **Критерий Сэвиджа (минимаксного сожаления):** Критерий минимизации упущенной выгоды. Сначала строится матрица «сожалений» (разница между максимальным возможным выигрышем при данном состоянии природы и реальным выигрышем), а затем выбирается альтернатива, минимизирующая максимальное сожаление. `min(max(r_ij))`
*   **Критерий Лапласа (равной вероятности):** Предполагается, что все состояния природы равновероятны. Выбирается альтернатива, максимизирующая средний выигрыш. `max(avg(a_ij))`

### 23. Теория принятия решений: Сравнение критериев

**Вопрос:** В чем отличия [заданного] критерия от [заданного] критерия?

**Ответ:** Ответ на этот вопрос требует сравнения двух критериев из списка выше. Например, отличие критерия Вальда от максимаксного заключается в **отношении к риску**. Критерий Вальда ориентирован на худший сценарий (пессимизм), в то время как максимаксный — на лучший (оптимизм). Критерий Гурвица является компромиссом между ними, а критерий Сэвиджа фокусируется не на абсолютном выигрыше, а на минимизации потерь от неправильного выбора.

### 24. Язык Си: Точка входа в программу

**Вопрос:** Имя функции, являющейся [продолжение вопроса] для программы на Си

**Ответ:** Точкой входа в любую программу на языке Си является функция `main()`.

### 25. Язык Си: Стандартная библиотека

**Вопрос:** Что из перечисленного есть в стандартной библиотеке языка Си

**Ответ:** Стандартная библиотека языка Си включает множество заголовочных файлов, предоставляющих функции для различных задач. Основные из них:

*   **`<stdio.h>`:** Функции ввода-вывода (например, `printf`, `scanf`, `fopen`, `fclose`).
*   **`<stdlib.h>`:** Функции общего назначения (например, `malloc`, `free` для управления памятью, `rand` для генерации случайных чисел, `exit` для завершения программы).
*   **`<string.h>`:** Функции для работы со строками (например, `strcpy`, `strlen`, `strcmp`).
*   **`<math.h>`:** Математические функции (например, `sin`, `cos`, `sqrt`, `pow`).
*   **`<time.h>`:** Функции для работы со временем и датой.

### 26. Язык C++: Стандартная библиотека

**Вопрос:** Что из перечисленного есть в стандартной библиотеке языка С++

**Ответ:** Стандартная библиотека C++ включает в себя всю стандартную библиотеку Си, а также множество собственных компонентов, в первую очередь **Standard Template Library (STL)**. Ключевые компоненты STL:

*   **Контейнеры:** Классы для хранения коллекций объектов (например, `vector`, `list`, `deque`, `set`, `map`).
*   **Итераторы:** Объекты, предоставляющие унифицированный доступ к элементам контейнеров.
*   **Алгоритмы:** Функции для выполнения операций над элементами контейнеров (например, `sort`, `find`, `copy`, `for_each`).
*   **Потоки ввода-вывода (`<iostream>`):** Объекты `cin`, `cout`, `cerr` для работы с консольным вводом-выводом.
*   **Строки (`<string>`):** Класс `std::string` для удобной работы со строками.

### 27. Теория принятия решений: Классификация задач

**Вопрос:** Задачи принятия решений классифицируются по следующим признакам:

**Ответ:** Задачи принятия решений классифицируются по нескольким основным признакам:

*   **По степени определенности информации:**
    *   **В условиях определенности:** Все исходы известны заранее.
    *   **В условиях риска:** Известны возможные исходы и их вероятности.
    *   **В условиях неопределенности:** Известны возможные исходы, но их вероятности неизвестны.
*   **По количеству критериев:**
    *   **Однокритериальные:** Выбор осуществляется по одному критерию.
    *   **Многокритериальные:** Выбор осуществляется по нескольким, часто противоречивым, критериям.
*   **По количеству этапов:**
    *   **Одноэтапные:** Решение принимается один раз.
    *   **Многоэтапные (динамические):** Решение принимается в несколько этапов, и решение на каждом этапе зависит от предыдущих.
*   **По количеству ЛПР:**
    *   **Индивидуальные:** Решение принимает один человек.
    *   **Коллективные (групповые):** Решение принимает группа лиц.

### 28. Криптография: Схемы шифрования

**Вопрос:** Какой из указанных алгоритмов шифрования реализован не по [ указана схема шифрования ] ?

**Ответ:** Этот вопрос требует знания различных схем и режимов шифрования. Например, если указана **схема Фейстеля**, то нужно знать, что алгоритмы **DES** и **ГОСТ 28147-89** основаны на ней, а **AES** — нет (он основан на SP-сети). Если речь идет о режимах работы блочных шифров (ECB, CBC, CFB, OFB, CTR), нужно знать их особенности и отличия.

### 29. Теория массового обслуживания (ТМО): Потоки событий

**Вопрос:** Каким набором свойств обладает [заданный] поток событий

**Ответ:** В ТМО часто рассматривается **простейший (пуассоновский) поток событий**. Он обладает следующими свойствами:

*   **Стационарность:** Вероятность наступления определенного числа событий на интервале времени зависит только от длины этого интервала, а не от его расположения на временной оси.
*   **Отсутствие последействия:** Вероятность наступления событий в будущем не зависит от того, сколько событий произошло в прошлом.
*   **Ординарность:** Вероятность наступления двух или более событий за малый промежуток времени пренебрежимо мала (события происходят поодиночке).

### 30. 3D-графика: Растровая графика

**Вопрос:** Как называется [определение] в 3D растровой графике?

**Ответ:** В 3D-графике, которая в конечном итоге отображается на растровом дисплее, используются различные понятия. Если речь идет о трехмерном аналоге пикселя, то это **воксель (voxel)** — элемент объемного изображения. Если вопрос касается процесса преобразования векторного представления 3D-сцены в растровое изображение, то это **растеризация (rasterization)**.

### 31. Теория информации: Минимальное число вопросов

**Вопрос:** Каково минимальное число вопросов, подразумевающих ответ «да» или «нет», которые необходимо задать, чтобы выяснить,[завершение вопроса]?

**Ответ:** Эта задача связана с теорией информации и двоичным кодированием. Если нужно выбрать один из `N` равновероятных вариантов, то минимальное число вопросов `k` определяется как `k = ⌈log₂(N)⌉`, где `⌈x⌉` — округление `x` до ближайшего целого в большую сторону. Каждый вопрос «да/нет» позволяет отсечь половину оставшихся вариантов.

### 32. Архитектура ЭВМ: Разрядность процессора

**Вопрос:** Если машинное слово выглядит так [машинное слово], то разрядность процессора равна:

**Ответ:** Разрядность процессора определяется размером машинного слова, то есть количеством битов, которые процессор может обрабатывать за одну операцию. Нужно просто посчитать количество битов в приведенном машинном слове. Например, если машинное слово `10110010 11010111 00101010 11110000`, то разрядность процессора — 32 бита.

### 33. Криптография: Типы шифрования

**Вопрос:** При [тип шифрования] шифровании используется:

**Ответ:**

*   При **симметричном** шифровании используется **один и тот же секретный ключ** для шифрования и расшифровки.
*   При **асимметричном** шифровании используется **пара ключей: открытый и закрытый**.
*   При **гибридном** шифровании используется комбинация: **асимметричный алгоритм** для безопасной передачи **секретного ключа**, а затем **симметричный алгоритм** для шифрования основного объема данных этим ключом.

### 34. Компьютерные сети: Коммутаторы

**Вопрос:** [начало вопроса - определение коммутатора] коммутатором становится коммутатор, имеющий:

**Ответ:** Вопрос, вероятно, касается выбора корневого коммутатора (Root Bridge) в сетях с протоколом STP (Spanning Tree Protocol). Корневым становится коммутатор, имеющий **наименьший идентификатор моста (Bridge ID)**. Bridge ID состоит из двух частей: **приоритета моста (Bridge Priority)** и **MAC-адреса коммутатора**. Сначала сравниваются приоритеты, и коммутатор с меньшим приоритетом побеждает. Если приоритеты равны, сравниваются MAC-адреса, и побеждает коммутатор с меньшим MAC-адресом.

### 35. Криптография: Свойства хеш-функций

**Вопрос:** Какое утверждение, касающееся свойств хеш-функции, является ошибочным?

**Ответ:** Криптографические хеш-функции должны обладать следующими свойствами:

1.  **Сопротивление прообразу (Preimage resistance):** Для данного хеша `h` должно быть вычислительно сложно найти сообщение `m` такое, что `hash(m) = h`.
2.  **Сопротивление второму прообразу (Second preimage resistance):** Для данного сообщения `m₁` должно быть вычислительно сложно найти другое сообщение `m₂` такое, что `hash(m₁) = hash(m₂)`.
3.  **Сопротивление коллизиям (Collision resistance):** Должно быть вычислительно сложно найти любую пару сообщений `m₁` и `m₂` таких, что `hash(m₁) = hash(m₂)`.

Ошибочным будет утверждение, которое противоречит одному из этих свойств. Например, утверждение, что «хеш-функция является обратимой» или «легко найти два разных сообщения с одинаковым хешем».

### 36. Методы оптимизации: Методы прямого поиска

**Вопрос:** В чем состоит отличие методов прямого поиска от прочих методов в задаче [указан вариант] оптимизации?

**Ответ:** Методы прямого поиска (или методы нулевого порядка) отличаются от других методов оптимизации (например, градиентных методов) тем, что они **не используют производные целевой функции**. Они оперируют только значениями самой функции в различных точках. Это делает их применимыми для негладких, разрывных или зашумленных функций, где производные могут не существовать или их вычисление затруднено.

Примеры методов прямого поиска: метод Нелдера-Мида (метод деформируемого многогранника), метод Хука-Дживса.

### 37. Линейное программирование

**Вопрос:** Может ли задача [указана задача] быть сведена к задаче линейного программирования?

**Ответ:** Задача может быть сведена к задаче линейного программирования (ЗЛП), если ее математическая модель удовлетворяет следующим условиям:

1.  **Целевая функция является линейной** относительно управляемых переменных.
2.  **Все ограничения являются линейными** (выражены в виде линейных равенств или неравенств).

Примеры задач, сводимых к ЗЛП: задача о диете, транспортная задача, задача о назначениях. Задачи, где целевая функция или ограничения нелинейны (например, содержат квадраты переменных или их произведения), относятся к нелинейному программированию.

### 38. Стратегии оптимизации / ТПР

**Вопрос:** Какое высказывание [о стратегиях из области оптимизации / ТПР ] является верным?

**Ответ:** Этот вопрос требует знания и сравнения различных стратегий, таких как пассивный и последовательный поиск в оптимизации, или критерии Вальда, Сэвиджа, Гурвица в ТПР. Верным будет утверждение, корректно описывающее свойства или назначение одной из этих стратегий (см. вопросы 20, 21, 22).

### 39. Структуры данных: Операции

**Вопрос:** Какие операции определены для структуры данных [указана типовая структура данных]

**Ответ:** Для каждой структуры данных определен свой набор операций:

*   **Стек (Stack):** `push` (добавить элемент в вершину), `pop` (удалить элемент из вершины), `peek` или `top` (посмотреть элемент в вершине). Работает по принципу LIFO (Last-In, First-Out).
*   **Очередь (Queue):** `enqueue` (добавить элемент в конец), `dequeue` (удалить элемент из начала), `front` (посмотреть элемент в начале). Работает по принципу FIFO (First-In, First-Out).
*   **Связный список (Linked List):** Вставка, удаление, поиск элемента.
*   **Дерево (Tree):** Вставка, удаление, поиск узла, обход дерева (в глубину, в ширину).
*   **Хеш-таблица (Hash Table):** Вставка, удаление, поиск элемента по ключу.

### 40. Компьютерные сети: Стандартные порты

**Вопрос:** Номер стандартного порта для протокола [указан сетевой протокол]

**Ответ:** Стандартные (хорошо известные) порты:

*   **FTP:** 20 (данные), 21 (управление)
*   **SSH:** 22
*   **Telnet:** 23
*   **SMTP:** 25
*   **DNS:** 53
*   **HTTP:** 80
*   **POP3:** 110
*   **IMAP:** 143
*   **HTTPS:** 443

### 41. Язык Си: Синтаксис функций

**Вопрос:** [Вопрос про синтаксис функции на языке Си]

**Ответ:** Общий синтаксис определения функции в Си:

`тип_возвращаемого_значения имя_функции(тип_параметра1 имя_параметра1, ...)`
`{`
`    // Тело функции`
`    return значение; // Если тип возвращаемого значения не void`
`}`

Вопрос может касаться правильного объявления указателей на функции, передачи массивов в функции, использования `void` и т.д.

### 42. Теория массового обслуживания: Марковские процессы

**Вопрос:** Выберите [указано, что выбрать] для характеристики марковских процессов

**Ответ:** Марковский процесс (или цепь Маркова) — это случайный процесс, обладающий **марковским свойством**: будущее состояние системы зависит только от ее настоящего состояния и не зависит от прошлого. Для его характеристики используются такие понятия, как:

*   **Состояния системы**
*   **Вероятности перехода** из одного состояния в другое
*   **Матрица переходных вероятностей**
*   **Стационарное распределение вероятностей** состояний

### 43. Компьютерная графика: Терминология

**Вопрос:** Какое из наименований не является названием [ понятие из компьютерной графики ] ?

**Ответ:** Вопрос на знание синонимов или связанных понятий. Например, если речь идет о **моделях цветопередачи**, то `RGB`, `CMYK`, `HSV` являются ими, а `JPEG` — нет (это формат сжатия изображений).

### 44. Защита информации: Терминология

**Вопрос:** [понятие из области защиты информации ] - это

**Ответ:** Требуется дать определение одному из базовых понятий:

*   **Конфиденциальность:** Свойство информации быть доступной только авторизованным пользователям.
*   **Целостность:** Свойство информации сохранять свою структуру и содержание в процессе передачи и хранения.
*   **Доступность:** Свойство информации быть доступной для авторизованных пользователей по запросу.
*   **Аутентификация:** Проверка подлинности пользователя или ресурса.
*   **Авторизация:** Предоставление прав доступа к ресурсам.

### 45. Компьютерные сети: Терминология

**Вопрос:** [ понятие из области компьютерных сетей ] - это:

**Ответ:** Требуется дать определение одному из базовых понятий:

*   **Протокол:** Набор правил и соглашений, определяющих формат и порядок обмена данными между устройствами.
*   **Топология:** Физическое или логическое расположение узлов и связей в сети (например, шина, звезда, кольцо).
*   **IP-адрес:** Уникальный числовой идентификатор устройства в сети, работающей по протоколу IP.
*   **MAC-адрес:** Уникальный идентификатор, присвоенный сетевому интерфейсу на заводе-изготовителе.

### 46. Компьютерные сети: Сравнение типов сетей

**Вопрос:** Какая разница между [один тип компьютерных сетей] и [другой тип компьютерных сетей] ?

**Ответ:** Вопрос может касаться сравнения:

*   **LAN (Local Area Network) и WAN (Wide Area Network):** LAN — локальная сеть, охватывающая небольшую территорию (здание, кампус). WAN — глобальная сеть, охватывающая большие географические расстояния.
*   **Клиент-серверная и одноранговая (peer-to-peer) архитектура:** В клиент-серверной есть выделенные серверы, предоставляющие ресурсы, и клиенты, их запрашивающие. В одноранговой сети все узлы равноправны и могут выступать как в роли клиента, так и в роли сервера.
*   **Коммутация каналов и коммутация пакетов:** При коммутации каналов (телефонная сеть) перед передачей данных устанавливается выделенный физический канал. При коммутации пакетов (Интернет) данные разбиваются на пакеты, которые передаются по сети независимо друг от друга.

### 47. Архитектура ЭВМ: Архитектура системы команд

**Вопрос:** Какие особенности [указана архитектура системы команд компьютера / процессора] в перечисленном списке НЕ относятся к основным :

**Ответ:** Вопрос, скорее всего, касается сравнения архитектур **CISC (Complex Instruction Set Computer)** и **RISC (Reduced Instruction Set Computer)**.

*   **Основные черты CISC:**
    *   Большой набор сложных инструкций.
    *   Инструкции переменной длины.
    *   Множество режимов адресации.
    *   Операции могут выполняться как с регистрами, так и с памятью.
*   **Основные черты RISC:**
    *   Сокращенный набор простых, быстрых инструкций.
    *   Инструкции фиксированной длины.
    *   Операции типа «загрузка/сохранение» (load/store) для доступа к памяти, остальные операции — только с регистрами.
    *   Большое количество регистров общего назначения.

Не относящейся к основным может быть какая-то второстепенная особенность или особенность, присущая другой архитектуре.

### 48. САПР: AutoCAD

**Вопрос:** Чем характеризуется в системе AutoCAD указанный атрибут

**Ответ:** Вопрос требует знаний специфики системы автоматизированного проектирования AutoCAD. Атрибуты в AutoCAD — это текстовые данные, связанные с блоками. Они позволяют хранить информацию, такую как инвентарный номер, стоимость, производитель и т.д. Характеристики атрибута включают его имя (тег), значение, подсказку, режим (видимый, скрытый, постоянный и т.д.).

### 49. Методы оптимизации: Модификации методов

**Вопрос:** В чем отличие [указана модификация метода оптимизации] от других модификаций?

**Ответ:** Вопрос может касаться различных модификаций градиентных методов или других численных методов. Например, **метод сопряженных градиентов** отличается от **метода наискорейшего спуска** тем, что он выбирает направления спуска таким образом, чтобы они были сопряженными, что обеспечивает сходимость за меньшее число итераций для квадратичных функций. **Квазиньютоновские методы** (например, DFP, BFGS) отличаются от **метода Ньютона** тем, что они не вычисляют матрицу вторых производных (гессиан) напрямую, а строят ее аппроксимацию.

### 50. SQL: Типы операций

**Вопрос:** Операции [...] и [...] в SQL относятся к операциям

**Ответ:** Операции в SQL делятся на несколько групп:

*   **DDL (Data Definition Language):** Язык определения данных. Операторы для создания и изменения структуры объектов БД.
    *   `CREATE` (создать)
    *   `ALTER` (изменить)
    *   `DROP` (удалить)
*   **DML (Data Manipulation Language):** Язык манипулирования данными. Операторы для работы с данными в таблицах.
    *   `SELECT` (выбрать)
    *   `INSERT` (вставить)
    *   `UPDATE` (обновить)
    *   `DELETE` (удалить)
*   **DCL (Data Control Language):** Язык управления данными. Операторы для управления правами доступа.
    *   `GRANT` (предоставить права)
    *   `REVOKE` (отозвать права)
*   **TCL (Transaction Control Language):** Язык управления транзакциями.
    *   `COMMIT` (подтвердить транзакцию)
    *   `ROLLBACK` (откатить транзакцию)
    *   `SAVEPOINT` (сохранить точку)

### 51. Компьютерные сети: Функции протоколов

**Вопрос:** Протокол [указан сетевой протокол] обеспечивает:

**Ответ:**

*   **TCP (Transmission Control Protocol):** Обеспечивает **надежную, упорядоченную доставку данных с установлением соединения**. Включает механизмы контроля ошибок, управления потоком и перегрузкой.
*   **UDP (User Datagram Protocol):** Обеспечивает **быструю, ненадежную доставку данных без установления соединения**. Не гарантирует доставку, порядок и целостность пакетов. Используется в приложениях, где важна скорость, а не надежность (например, потоковое видео, онлайн-игры, DNS).
*   **IP (Internet Protocol):** Обеспечивает **маршрутизацию пакетов** между сетями, но не гарантирует их доставку (ненадежный протокол).
*   **ICMP (Internet Control Message Protocol):** Обеспечивает **обмен управляющими сообщениями и сообщениями об ошибках** (например, утилита `ping`).

### 52. Веб-технологии: Document Object Model (DOM)

**Вопрос:** Что такое Document Object Model ?

**Ответ:** Document Object Model (DOM) — это **программный интерфейс (API) для HTML и XML документов**. Он представляет структуру документа в виде дерева, где каждый узел является объектом, представляющим часть документа (например, элемент, атрибут, текст). DOM позволяет программам и скриптам (в частности, JavaScript) динамически получать доступ и изменять содержимое, структуру и стиль документа. Благодаря DOM веб-страницы могут быть интерактивными.

### 53. Парадигмы программирования

**Вопрос:** Какие парадигмы программирования поддерживает язык [указан язык программирования]

**Ответ:** Многие современные языки являются мультипарадигменными:

*   **C++:** Процедурное, объектно-ориентированное, обобщенное.
*   **Java:** Объектно-ориентированное, (частично) функциональное (с Java 8).
*   **Python:** Объектно-ориентированное, процедурное, функциональное.
*   **JavaScript:** Прототипное (разновидность объектно-ориентированного), функциональное, императивное.
*   **C#:** Объектно-ориентированное, функциональное, компонентно-ориентированное.

### 54. Язык Си: Определение конструкций

**Вопрос:** В языке Си при определении [указано, что определяется]:

**Ответ:** Вопрос может касаться синтаксиса определения различных конструкций:

*   **Массив:** `тип имя[размер];`
*   **Структура:** `struct имя_структуры { тип поле1; тип поле2; };`
*   **Указатель:** `тип *имя_указателя;`
*   **Функция:** (см. вопрос 41)

### 55. Теория автоматов: Сети Петри

**Вопрос:** Какая из задач сетей Петри имеет следующую формулировку:[формулировка]

**Ответ:** Сети Петри — это математический аппарат для моделирования динамических дискретных систем. Основные задачи анализа сетей Петри:

*   **Задача достижимости:** Можно ли из начальной маркировки (состояния) достичь заданной конечной маркировки?
*   **Задача ограниченности:** Является ли число фишек в каждой позиции ограниченным при любой достижимой маркировке?
*   **Задача живости:** Может ли каждый переход сработать из любой достижимой маркировки (возможно, после некоторой последовательности срабатываний других переходов)?

### 56. Имитационное моделирование: Случайные процессы

**Вопрос:** [Вопрос про характеристики случайного процесса при имитационном моделировании]

**Ответ:** Вопрос может касаться таких характеристик, как **математическое ожидание, дисперсия, функция распределения, корреляционная функция**. Также могут затрагиваться типы случайных процессов (стационарные, эргодические) и методы их генерации в моделях.

### 57. Идентификация систем

**Вопрос:** Выберите положения, на которых основывается [один из методов построения моделей идентификации]

**Ответ:** Идентификация — это построение математической модели системы по экспериментальным данным (входным и выходным сигналам). Методы могут основываться на:

*   **Метод наименьших квадратов (МНК):** Минимизация суммы квадратов отклонений выходов модели от реальных выходов системы.
*   **Корреляционный анализ:** Построение модели на основе корреляционных функций входных и выходных сигналов.
*   **Методы, основанные на нейронных сетях или нечеткой логике.**

### 58. Криптография: Преобразования данных

**Вопрос:** [Вариант преобразования данных] используют:

**Ответ:** В блочных шифрах используются различные преобразования:

*   **Подстановка (Substitution):** Замена блока данных на другой блок в соответствии с таблицей замен (S-блок). Обеспечивает нелинейность и устойчивость к линейному криптоанализу.
*   **Перестановка (Permutation):** Изменение порядка битов внутри блока. Обеспечивает рассеивание (диффузию).

Алгоритм **AES** использует оба этих преобразования (операции `SubBytes` и `ShiftRows`/`MixColumns`). Алгоритм **DES** также использует подстановки и перестановки в рамках схемы Фейстеля.

### 59. Компьютерная графика: Пространства

**Вопрос:** В каком пространстве происходит работа в случае использования [вариант компьютерной графики]

**Ответ:**

*   **Векторная графика:** Работа происходит в **объектном (или мировом) пространстве**, где объекты описываются математическими формулами (координатами вершин, кривыми). Это пространство может быть 2D или 3D.
*   **Растровая графика:** Работа происходит в **пространстве изображения (или экранном пространстве)**, которое представляет собой двумерную сетку пикселей.
*   **3D-графика:** Включает последовательность преобразований между пространствами: локальное (модельное) -> мировое -> видовое (камеры) -> проекционное -> экранное.

### 60. Компьютерные сети: Административное расстояние

**Вопрос:** Какое административное расстояние использует [указан сетевой протокол] ?

**Ответ:** Административное расстояние (Administrative Distance, AD) — это метрика, используемая маршрутизаторами (в частности, Cisco) для выбора наилучшего маршрута, когда есть несколько маршрутов к одному и тому же месту назначения, полученных от разных протоколов маршрутизации. Чем меньше значение AD, тем надежнее считается протокол.

*   **Directly Connected (непосредственно подключенная сеть):** 0
*   **Static Route (статический маршрут):** 1
*   **EIGRP:** 90
*   **OSPF:** 110
*   **RIP:** 120

### 61. Численные методы: Итерационные процессы

**Вопрос:** Итерационный процесс в [методе оптимизации / численном методе] записывается в виде:

**Ответ:** Вопрос требует знания формулы конкретного итерационного метода:

*   **Метод градиентного спуска:** `x_(k+1) = x_k - α * grad(f(x_k))`
*   **Метод Ньютона (для решения f(x)=0):** `x_(k+1) = x_k - f(x_k) / f'(x_k)`
*   **Метод простой итерации (для решения x=φ(x)):** `x_(k+1) = φ(x_k)`

### 62. PHP: Синтаксис

**Вопрос:** С помощью какого символа в PHP можно [что-то сделать]?

**Ответ:** Вопрос на знание базового синтаксиса PHP:

*   **`$`:** Переменные начинаются с символа доллара (например, `$my_var`).
*   **`->`:** Оператор доступа к свойствам и методам объекта.
*   **`::`:** Оператор разрешения области видимости (для доступа к статическим свойствам и методам).
*   **`.`:** Оператор конкатенации строк.

### 63. Теория принятия решений: Применение критериев

**Вопрос:** Критерий [указан критерий из теории принятия решений] применяется в случае, когда:

**Ответ:**

*   **Критерий Вальда:** Применяется, когда ЛПР является крайним пессимистом и хочет гарантировать себе определенный минимальный выигрыш, избегая риска.
*   **Максимаксный критерий:** Применяется, когда ЛПР — азартный игрок, оптимист, готовый рисковать ради максимального выигрыша.
*   **Критерий Гурвица:** Применяется, когда ЛПР имеет промежуточное отношение к риску, не являясь ни крайним пессимистом, ни оптимистом.
*   **Критерий Сэвиджа:** Применяется, когда ЛПР хочет минимизировать сожаление об упущенной выгоде, то есть минимизировать потери от принятия не самого лучшего решения.
*   **Критерий Лапласа:** Применяется, когда нет никаких оснований считать одно состояние природы более вероятным, чем другое, и ЛПР готов принять гипотезу об их равной вероятности.

### 64. Теория принятия решений: Критерий Гурвица

**Вопрос:** При коэффициенте [коэффициент] критерий [указан критерий из теории принятия решений] превращается в …

**Ответ:** Вопрос касается критерия Гурвица. Его формула: `H = α * max(a_ij) + (1-α) * min(a_ij)`.

*   При коэффициенте оптимизма **`α = 0`**, критерий Гурвица превращается в **критерий Вальда** (`H = min(a_ij)`).
*   При коэффициенте оптимизма **`α = 1`**, критерий Гурвица превращается в **максимаксный критерий** (`H = max(a_ij)`).

### 65. Язык Си: Статические массивы

**Вопрос:** Какие из утверждений справедливы для статических массивов в языке Си

**Ответ:**

*   **Размер фиксирован:** Размер статического массива должен быть известен на этапе компиляции и не может быть изменен во время выполнения программы.
*   **Память выделяется на стеке (для локальных массивов) или в сегменте данных (для глобальных/статических).**
*   **Имя массива является константным указателем** на его первый элемент. Ему нельзя присвоить другой адрес.
*   **Нет контроля выхода за границы:** Язык Си не контролирует выход за пределы массива, что может привести к неопределенному поведению и ошибкам.

### 66. Язык C++: Наследование

**Вопрос:** Выберите верные утверждения про наследование в языке С++

**Ответ:**

*   **Типы наследования:** `public`, `protected`, `private`. Тип наследования определяет, как изменяются спецификаторы доступа унаследованных членов в производном классе.
*   **`public` наследование:** `public` члены базового класса становятся `public` в производном, `protected` остаются `protected`. Это моделирует отношение «является» (is-a).
*   **Множественное наследование:** Класс может наследовать от нескольких базовых классов. Это может привести к проблеме ромбовидного наследования, которая решается с помощью виртуального наследования.
*   **Конструкторы и деструкторы не наследуются**, но вызываются автоматически при создании и уничтожении объектов производного класса.

### 67. HTTP: Методы

**Вопрос:** Какие из методов HTTP протокола [ обладают указанным свойством ] ?

**Ответ:** Вопрос может касаться свойств **идемпотентности** и **безопасности**.

*   **Безопасные методы:** Не изменяют состояние сервера. К ним относится **`GET`**, **`HEAD`**, **`OPTIONS`**.
*   **Идемпотентные методы:** Повторный вызов метода с теми же параметрами приводит к тому же результату, что и одиночный. К ним относятся все безопасные методы, а также **`PUT`** и **`DELETE`**.
*   **Неидемпотентный метод:** **`POST`**. Повторный вызов `POST` может привести к созданию нескольких ресурсов.

### 68. Веб-технологии: Серверные сценарии

**Вопрос:** Сценарии на стороне web-сервера [окончание вопроса про их особенности]

**Ответ:** Особенности серверных сценариев (например, на PHP, Python, Node.js):

*   **Выполняются на сервере:** Код выполняется на веб-сервере, а клиенту (браузеру) отправляется только результат их выполнения, обычно в виде HTML-страницы.
*   **Доступ к ресурсам сервера:** Могут работать с базами данных, файловой системой и другими ресурсами сервера.
*   **Сокрытие логики:** Исходный код серверных сценариев не виден пользователю.
*   **Генерация динамического контента:** Позволяют создавать страницы, содержимое которых зависит от запроса пользователя, данных из БД и т.д.

### 69. Моделирование: Терминология

**Вопрос:** Выберите определения, относящиеся к термину [термин из области моделирования].

**Ответ:**

*   **Модель:** Упрощенное представление реального объекта, системы или процесса.
*   **Адекватность модели:** Степень соответствия модели реальному объекту по интересующим нас свойствам.
*   **Имитационное моделирование:** Метод исследования, при котором изучаемая система заменяется моделью, с достаточной точностью описывающей реальную систему, и с ней проводятся эксперименты с целью получения информации об этой системе.

### 70. Криптография: Типы алгоритмов шифрования

**Вопрос:** Укажите характерную для [указан тип алгоритмов шифрования] особенность:

**Ответ:**

*   **Симметричные:** Высокая скорость, необходимость безопасной передачи ключа.
*   **Асимметричные:** Низкая скорость, решают проблему распределения ключей, используются для цифровой подписи.
*   **Блочные:** Шифруют данные блоками фиксированного размера.
*   **Потоковые:** Шифруют данные побитово или побайтово.

### 71. SQL: Операторы

**Вопрос:** Какой оператор языка SQL [выполняет указанное действие / преобразование] ?

**Ответ:**

*   **`JOIN`:** Объединяет строки из двух или более таблиц на основе связанного столбца.
*   **`GROUP BY`:** Группирует строки с одинаковыми значениями в сводные строки.
*   **`HAVING`:** Фильтрует результаты `GROUP BY` на основе заданного условия.
*   **`ORDER BY`:** Сортирует результирующий набор.
*   **`UNION`:** Объединяет результаты двух или более `SELECT` запросов.

### 72. Компьютерная графика: Графические форматы

**Вопрос:** К файлам какого графического формата данных применимо понятие [указано понятие] ?

**Ответ:**

*   **Сжатие с потерями (Lossy compression):** **JPEG**. Применимо для фотографий.
*   **Сжатие без потерь (Lossless compression):** **PNG, GIF, BMP**. Применимо для изображений с четкими границами, текста, логотипов.
*   **Анимация:** **GIF, APNG**.
*   **Прозрачность:** **PNG, GIF**.
*   **Векторное представление:** **SVG**.

### 73. Криптография: Шифрование Алисой и Бобом

**Вопрос:** Для реализации шифрования Алисой и расшифровки Бобом необходим (применяется) [указан тип алгоритма шифрования]):

**Ответ:** Это классический сценарий использования **асимметричного шифрования**.

*   Алиса хочет отправить секретное сообщение Бобу.
*   Алиса берет **открытый ключ Боба** и шифрует им сообщение.
*   Боб получает зашифрованное сообщение и расшифровывает его с помощью своего **закрытого ключа**.

Таким образом, для шифрования Алисой и расшифровки Бобом необходим **открытый ключ Боба** и **закрытый ключ Боба**.

### 74. HTML: Версии стандарта

**Вопрос:** Что из перечисленного появилось только в [указанной версии стандарта HTML]

**Ответ:** Вопрос, скорее всего, касается **HTML5**. Новые элементы и API, появившиеся в HTML5:

*   **Семантические теги:** `<article>`, `<section>`, `<nav>`, `<header>`, `<footer>`.
*   **Мультимедиа:** `<audio>`, `<video>`.
*   **Графика:** `<canvas>`, `<svg>`.
*   **Формы:** Новые типы полей ввода (`date`, `email`, `number`), атрибуты (`required`, `placeholder`).
*   **API:** Geolocation, Web Storage (localStorage, sessionStorage), Web Workers.

### 75. Компьютерная графика: Понятия

**Вопрос:** Что такое [понятие из области компьютерной графики] ?

**Ответ:**

*   **Шейдер (Shader):** Программа, выполняемая на графическом процессоре (GPU) и определяющая, как будут отрисованы вершины и пиксели.
*   **Текстура (Texture):** Изображение, накладываемое на поверхность 3D-модели для придания ей детализации и реалистичности.
*   **Рендеринг (Rendering):** Процесс получения финального изображения из 3D-модели.
*   **Сглаживание (Anti-aliasing):** Технология для устранения «лесенек» (зубчатых краев) на изображении.

### 76. Криптография: Режимы работы шифров

**Вопрос:** Вопрос о режимах работы шифров

**Ответ:** Режимы работы определяют, как блочный шифр применяется к последовательности блоков данных.

*   **ECB (Electronic Codebook):** Самый простой режим. Каждый блок шифруется независимо. Недостаток: одинаковые блоки открытого текста превращаются в одинаковые блоки шифротекста, что небезопасно.
*   **CBC (Cipher Block Chaining):** Каждый блок открытого текста перед шифрованием складывается по XOR с предыдущим блоком шифротекста. Требует вектора инициализации (IV). Более безопасен, чем ECB.
*   **CFB (Cipher Feedback):** Превращает блочный шифр в потоковый. Шифруется не блок открытого текста, а результат шифрования предыдущего блока шифротекста, который затем складывается по XOR с открытым текстом.
*   **OFB (Output Feedback):** Также превращает блочный шифр в потоковый. Генерирует гамму, которая складывается по XOR с открытым текстом. Гамма генерируется путем последовательного шифрования IV.
*   **CTR (Counter):** Также потоковый режим. Генерирует гамму путем шифрования последовательных значений счетчика.

### 77. ООП в C++: Особенности реализации

**Вопрос:** Вопрос об особенностях реализации ООП в С++

**Ответ:** Может касаться таких тем, как:

*   **RAII (Resource Acquisition Is Initialization):** Идиома, связывающая время жизни ресурса (память, файл, сокет) с временем жизни объекта. Ресурс захватывается в конструкторе и освобождается в деструкторе, что обеспечивает автоматическое управление ресурсами.
*   **Виртуальные деструкторы:** Необходимы при работе с полиморфными базовыми классами, чтобы при удалении объекта через указатель на базовый класс корректно вызывался деструктор производного класса.
*   **Правило трех/пяти/нуля:** Руководство по написанию классов, управляющих ресурсами, определяющее, когда нужно явно определять конструктор копирования, оператор присваивания и деструктор.

### 78. Защита информации: Сертификаты

**Вопрос:** Вопрос о сертификатах [из Защиты информации].

**Ответ:** Вопрос, скорее всего, о **сертификатах открытого ключа (X.509)**. Это электронный документ, который связывает открытый ключ с определенной информацией о его владельце (имя, организация и т.д.). Сертификат подписывается **центром сертификации (Certification Authority, CA)**, который своей цифровой подписью подтверждает подлинность этой связи. Сертификаты являются основой инфраструктуры открытых ключей (PKI) и используются, например, в протоколе TLS/SSL для аутентификации веб-сайтов.

### 79. Защита информации: Протоколы защиты

**Вопрос:** Вопрос о протоколе защиты [особенности использования протокола и его параметров безопасности].

**Ответ:** Может касаться протоколов **TLS/SSL**, **IPsec**, **SSH**.

*   **TLS/SSL (Transport Layer Security / Secure Sockets Layer):** Обеспечивает защищенную передачу данных между клиентом и сервером поверх TCP. Использует гибридное шифрование: асимметричное для аутентификации и обмена сеансовым ключом, и симметричное для шифрования данных.
*   **IPsec (Internet Protocol Security):** Набор протоколов для защиты данных на сетевом уровне (IP). Может обеспечивать аутентификацию, целостность и конфиденциальность IP-пакетов.
*   **SSH (Secure Shell):** Протокол для безопасного удаленного управления операционными системами и туннелирования TCP-соединений.

### 80. Компьютерные сети: Потоки

**Вопрос:** Поток в сети удовлетворяет следующим свойствам

**Ответ:** Вопрос может быть связан с понятием потока в транспортной сети (задача о максимальном потоке). Поток — это функция, определенная на дугах графа, и она должна удовлетворять двум свойствам:

1.  **Ограничение пропускной способности:** Поток по любой дуге не может превышать ее пропускную способность.
2.  **Сохранение потока:** Для любой промежуточной вершины (кроме источника и стока) входящий поток равен исходящему.

### 81. Теория принятия решений: Критерии

**Вопрос:** На какие критерии опирается [указан критерий из теории принятия решений]?

**Ответ:**

*   **Критерий Вальда:** Опирается на **минимальный** выигрыш для каждой альтернативы.
*   **Максимаксный критерий:** Опирается на **максимальный** выигрыш для каждой альтернативы.
*   **Критерий Гурвица:** Опирается на **минимальный и максимальный** выигрыши, взвешенные с коэффициентом оптимизма.
*   **Критерий Сэвиджа:** Опирается на **максимальное сожаление (упущенную выгоду)** для каждой альтернативы.

### 82. Компьютерная графика: Однородные координаты

**Вопрос:** Сколько однородных координат описывает [объект в заданном пространстве] ?

**Ответ:** Однородные координаты используются для упрощения аффинных преобразований (таких как перенос, масштабирование, поворот), представляя их в виде матричного умножения. Для этого к обычным координатам добавляется еще одна.

*   Для описания точки в **2D-пространстве** используется **3** однородные координаты (x, y, w).
*   Для описания точки в **3D-пространстве** используется **4** однородные координаты (x, y, z, w).

### 83. Реляционная теория БД: Понятия

**Вопрос:** Выберите верные утверждения о [понятии в реляционной теории БД]:

**Ответ:** Вопрос может касаться:

*   **Первичный ключ (Primary Key):** Уникально идентифицирует каждую запись в таблице. Не может содержать NULL-значения.
*   **Внешний ключ (Foreign Key):** Поле в одной таблице, которое ссылается на первичный ключ в другой таблице. Обеспечивает ссылочную целостность.
*   **Нормальные формы:**
    *   **1НФ:** Все атрибуты атомарны (неделимы).
    *   **2НФ:** Находится в 1НФ, и все неключевые атрибуты полностью зависят от первичного ключа (нет частичных зависимостей).
    *   **3НФ:** Находится в 2НФ, и нет транзитивных зависимостей неключевых атрибутов от первичного ключа.

### 84. Теория принятия решений: Этапы метода

**Вопрос:** Расставьте по порядку этапы метода [метод из ТПР]

**Ответ:** Вопрос может касаться **метода анализа иерархий (МАИ)**. Его этапы:

1.  Построение иерархии (цель, критерии, альтернативы).
2.  Построение матриц парных сравнений для каждого уровня иерархии.
3.  Вычисление весовых коэффициентов (векторов приоритетов) для элементов каждого уровня.
4.  Проверка согласованности суждений.
5.  Синтез глобальных приоритетов альтернатив.
6.  Выбор наилучшей альтернативы.

### 85. JavaScript: Синтаксис

**Вопрос:** Вопрос о синтаксисе JavaScript

**Ответ:** Может касаться особенностей языка, таких как:

*   **`var`, `let`, `const`:** Различия в объявлении переменных (область видимости, возможность переприсваивания).
*   **`==` vs `===`:** Нестрогое (с приведением типов) и строгое (без приведения типов) сравнение.
*   **Замыкания (Closures):** Функция «помнит» лексическое окружение, в котором она была создана.
*   **Прототипное наследование:** Объекты наследуют свойства и методы от других объектов через цепочку прототипов.
*   **Асинхронность (`Promise`, `async/await`):** Механизмы для работы с асинхронными операциями.

### 86. Криптография: Режимы шифрования

**Вопрос:** В каких режимах шифрования возможно [продолжение вопроса - заданное преобразование ]?

**Ответ:** Вопрос может касаться возможности **распараллеливания** шифрования или расшифровки.

*   **Шифрование можно распараллелить** в режимах **ECB** и **CTR**, так как каждый блок обрабатывается независимо.
*   **Расшифровку можно распараллелить** в режимах **ECB**, **CBC** и **CTR**.

### 87. HTTP: Методы

**Вопрос:** Вопрос о методах HTTP

**Ответ:** См. вопрос 67. Может быть задан вопрос о назначении конкретного метода, например:

*   **`GET`:** Запрос представления ресурса.
*   **`POST`:** Отправка данных на сервер для создания нового ресурса.
*   **`PUT`:** Замена существующего ресурса данными из тела запроса.
*   **`DELETE`:** Удаление указанного ресурса.
*   **`PATCH`:** Частичное изменение ресурса.

### 88. Криптография: Получение ключей

**Вопрос:** Каким образом получается [тип ключа] в алгоритме [указан алгоритм шифрования]?

**Ответ:**

*   **В блочных шифрах (DES, AES):** **Раундовые ключи** генерируются из основного секретного ключа с помощью **алгоритма расширения ключа (Key Schedule)**.
*   **В асимметричных алгоритмах (RSA):** **Открытый и закрытый ключи** генерируются вместе на основе больших простых чисел.
*   **В протоколе Диффи-Хеллмана:** **Общий секретный ключ** вырабатывается сторонами на основе их закрытых ключей и общих открытых параметров без прямой передачи самого ключа.



### 1. К языкам программирования высокого уровня относятся ...

Языки программирования высокого уровня (ЯВУ) — это языки, которые предоставляют более высокий уровень абстракции от аппаратного обеспечения компьютера, чем языки низкого уровня (например, ассемблер). Они используют синтаксис, близкий к естественному языку, и позволяют программистам сосредоточиться на логике программы, а не на деталях работы процессора и памяти. Примеры ЯВУ включают Python, Java, C++, C#, JavaScript, Ruby, PHP, Swift, Kotlin и многие другие.


### 2. Динамическим языком программирования называется язык, который…

Динамическим языком программирования называется язык, в котором многие операции, обычно выполняемые на этапе компиляции (например, проверка типов, связывание имен), выполняются во время выполнения программы (runtime). Это обеспечивает большую гибкость и позволяет изменять структуру программы "на лету", но может приводить к снижению производительности и обнаружению ошибок только во время выполнения. Примеры динамических языков: Python, JavaScript, Ruby, PHP, Perl, Lisp.


### 3. К базовым алгоритмическим структурам относятся ...

К базовым алгоритмическим структурам относятся:

*   **Последовательность (следование)**: Выполнение инструкций одна за другой в заданном порядке.
*   **Ветвление (выбор, развилка)**: Выполнение различных наборов инструкций в зависимости от выполнения некоторого условия (например, `if-else`, `switch-case`).
*   **Цикл (повторение)**: Многократное выполнение одного и того же набора инструкций до тех пор, пока выполняется или не выполняется некоторое условие (например, `for`, `while`, `do-while`).


### 4. Выраженное каким-либо образом личное суждение о.... [продолжение формулировки понятия из области ТПР] Дать короткую формулировку ответа

Это определение относится к понятию **предпочтение** в Теории Принятия Решений (ТПР). Предпочтение — это выраженное каким-либо образом личное суждение о сравнительной ценности или желательности различных альтернатив.


### 5. Какая проекция позволяет получить ... [продолжение формулировки] 3D объекта?

Для получения различных видов 3D объекта используются следующие проекции:

*   **Ортогональная (параллельная) проекция**: Используется для получения точных размеров и форм объекта, например, в инженерной графике. Лучи проекции параллельны друг другу и перпендикулярны плоскости проекции. Примеры: изометрическая, диметрическая, триметрическая проекции.
*   **Перспективная проекция**: Используется для создания реалистичного изображения объекта, как его видит человеческий глаз. Лучи проекции исходят из одной точки (центра проекции) и сходятся на плоскости проекции. Создает эффект глубины и удаленности.

Без полного контекста вопроса сложно сказать, какая именно проекция имеется в виду, но чаще всего речь идет об ортогональной или перспективной проекции в зависимости от цели получения изображения.


### 6. [начало формулировки - термин]... в теории БД называют:

В теории баз данных:

*   **Сущность (Entity)**: Объект реального мира, информация о котором хранится в базе данных (например, студент, книга, заказ).
*   **Атрибут (Attribute)**: Характеристика сущности (например, имя студента, название книги, дата заказа).
*   **Связь (Relationship)**: Ассоциация между двумя или более сущностями (например, студент *записан на* курс).
*   **Кортеж (Tuple)**: Строка в таблице реляционной базы данных, представляющая собой набор значений атрибутов для одной сущности.
*   **Домен (Domain)**: Множество допустимых значений для атрибута.
*   **Схема базы данных (Database Schema)**: Описание структуры базы данных, включая таблицы, поля, связи и ограничения.

Без конкретного начала формулировки сложно дать точный ответ, но это наиболее распространенные термины в теории БД.


### 7. Какой протокол используется для преобразования [указано преобразование сетевых адресов] ?

Если речь идет о преобразовании сетевых адресов, то наиболее вероятные протоколы:

*   **NAT (Network Address Translation)**: Протокол (или, точнее, механизм), используемый для преобразования IP-адресов частной сети в публичные IP-адреса и обратно. Это позволяет нескольким устройствам в частной сети использовать один публичный IP-адрес для доступа в Интернет.
*   **ARP (Address Resolution Protocol)**: Протокол разрешения адресов, используемый для преобразования IP-адреса в MAC-адрес (физический адрес) в локальной сети. Это необходимо для доставки пакетов данных на конкретное устройство в сегменте локальной сети.
*   **DNS (Domain Name System)**: Система доменных имен, используемая для преобразования доменных имен (например, `google.com`) в IP-адреса (например, `172.217.160.142`).

Без уточнения, какое именно преобразование сетевых адресов имеется в виду, сложно дать однозначный ответ.


### 8. На каком уровне модели OSI работает [указано сетевое оборудование ]?

Модель OSI (Open Systems Interconnection) состоит из семи уровней. Различное сетевое оборудование работает на разных уровнях:

*   **Физический уровень (1)**: Концентраторы (хабы), повторители (репитеры), кабели.
*   **Канальный уровень (2)**: Коммутаторы (свитчи), сетевые карты (NIC).
*   **Сетевой уровень (3)**: Маршрутизаторы (роутеры), многоуровневые коммутаторы (Layer 3 switches).
*   **Транспортный уровень (4)**: Некоторые межсетевые экраны (файрволы), балансировщики нагрузки.
*   **Сеансовый, Представительский, Прикладной уровни (5, 6, 7)**: Шлюзы (гейтвеи), прокси-серверы, некоторые межсетевые экраны, конечные приложения.

Без указания конкретного сетевого оборудования невозможно дать точный ответ.


### 9. К какому классу относится IP-адрес [указан IP адрес]?

Классификация IP-адресов (IPv4) по классам (A, B, C, D, E) основана на первых битах адреса. Эта классификация устарела и в настоящее время используется бесклассовая маршрутизация (CIDR), но для экзамена может быть актуальна:

*   **Класс A**: Первый октет от 1 до 126. (Начинается с `0xxxxxxx`, т.е. первый бит 0). Например, `10.0.0.1`.
*   **Класс B**: Первый октет от 128 до 191. (Начинается с `10xxxxxx`, т.е. первые два бита 10). Например, `172.16.0.1`.
*   **Класс C**: Первый октет от 192 до 223. (Начинается с `110xxxxx`, т.е. первые три бита 110). Например, `192.168.1.1`.
*   **Класс D**: Первый октет от 224 до 239. Используется для многоадресной рассылки (multicast). Например, `224.0.0.1`.
*   **Класс E**: Первый октет от 240 до 255. Зарезервирован для исследовательских целей. Например, `240.0.0.1`.

**Исключения:**
*   `127.x.x.x` (например, `127.0.0.1`) зарезервирован для локальной петли (localhost).
*   `0.x.x.x` зарезервирован.

Для ответа на этот вопрос необходимо знать конкретный IP-адрес.


### 10. Какой из протоколов является маршрутизируемым?

Маршрутизируемые протоколы — это протоколы сетевого уровня (уровень 3 модели OSI), которые содержат информацию об адресации, достаточную для того, чтобы маршрутизаторы могли пересылать пакеты данных между различными сетями. Наиболее известным и широко используемым маршрутизируемым протоколом является **IP (Internet Protocol)**. Другие примеры (исторические или специализированные): IPX/SPX, AppleTalk, DECnet.


### 11. Вопрос про реализацию ООП в С++

C++ является мультипарадигменным языком программирования, который полностью поддерживает объектно-ориентированное программирование (ООП). Основные концепции ООП в C++:

*   **Инкапсуляция**: Объединение данных (атрибутов) и методов (функций), работающих с этими данными, в единую сущность — класс. Доступ к данным обычно ограничивается (с помощью модификаторов доступа `public`, `private`, `protected`), что предотвращает их прямое изменение извне и обеспечивает целостность.
*   **Наследование**: Механизм, позволяющий создавать новые классы (производные классы) на основе существующих (базовых классов). Производный класс наследует атрибуты и методы базового класса, что способствует повторному использованию кода и созданию иерархий классов.
*   **Полиморфизм**: Способность объектов разных классов реагировать на один и тот же вызов метода по-разному. В C++ полиморфизм реализуется через виртуальные функции и указатели/ссылки на базовый класс. Это позволяет писать более гибкий и расширяемый код.
*   **Абстракция**: Выделение существенных характеристик объекта и скрытие несущественных деталей реализации. В C++ абстракция достигается с помощью абстрактных классов и интерфейсов (чисто виртуальных функций).

Дополнительные особенности реализации ООП в C++:

*   **Конструкторы и деструкторы**: Специальные методы, которые автоматически вызываются при создании и уничтожении объектов класса соответственно. Используются для инициализации и освобождения ресурсов.
*   **Перегрузка операторов**: Возможность определить поведение операторов (например, `+`, `-`, `*`, `/`) для пользовательских типов данных.
*   **Шаблоны (Templates)**: Механизм для создания обобщенного кода, который может работать с различными типами данных, не привязываясь к конкретному типу. Позволяет реализовать обобщенное программирование.
*   **Виртуальные функции и RTTI (Run-Time Type Information)**: Механизмы для поддержки полиморфизма во время выполнения программы.


### 12. Гарвардская архитектура отличается от фон-Неймановской ...

**Гарвардская архитектура** и **фон-Неймановская архитектура** — это два основных типа архитектур компьютерных систем, которые определяют способ организации памяти и взаимодействия с процессором.

**Фон-Неймановская архитектура (принцип хранимой программы)**:
*   **Единое адресное пространство**: Использует одну общую память для хранения как программных инструкций, так и данных. Процессор обращается к этой единой памяти для выборки инструкций и данных.
*   **Единая шина**: Для доступа к памяти используется одна шина (шина данных и шина адреса), что приводит к так называемому «бутылочному горлышку фон Неймана» — ограничению пропускной способности, поскольку процессор не может одновременно считывать инструкцию и данные.
*   **Последовательное выполнение**: Инструкции выполняются последовательно.
*   **Применение**: Большинство современных компьютеров (ПК, серверы) используют модифицированную фон-Неймановскую архитектуру.

**Гарвардская архитектура**:
*   **Раздельное адресное пространство**: Имеет отдельные, независимые памяти для хранения программных инструкций и данных. Каждая память имеет свою собственную шину.
*   **Раздельные шины**: Использует отдельные шины для доступа к памяти инструкций и памяти данных. Это позволяет процессору одновременно считывать инструкцию и данные, что значительно увеличивает пропускную способность и производительность.
*   **Параллельный доступ**: Возможность параллельного доступа к инструкциям и данным.
*   **Применение**: Часто используется во встраиваемых системах, цифровых сигнальных процессорах (DSP), микроконтроллерах, где важна высокая скорость выполнения и предсказуемость. Например, в микроконтроллерах AVR, PIC.

**Основные отличия**: Главное отличие заключается в **разделении памяти и шин для инструкций и данных в Гарвардской архитектуре**, что обеспечивает более высокую производительность за счет параллельного доступа, в то время как фон-Неймановская архитектура использует единую память и шину, что создает потенциальное «бутылочное горлышко».


### 13. С какого этапа начинается постановка задачи оптимизации ?

Постановка задачи оптимизации начинается с этапа **формулировки цели (целевой функции)** и **определения переменных (управляемых параметров)**. Это включает в себя:

1.  **Определение цели**: Четкое формулирование того, что именно нужно оптимизировать (минимизировать или максимизировать). Это приводит к созданию целевой функции.
2.  **Идентификация переменных**: Определение всех параметров, которые могут быть изменены для достижения цели оптимизации. Эти параметры становятся переменными оптимизации.
3.  **Определение ограничений**: Выявление всех условий и ограничений, которым должны удовлетворять переменные и целевая функция (например, бюджетные ограничения, временные рамки, физические пределы).


### 14. Какой этап – заключительный при постановке задачи оптимизации?

Заключительным этапом при постановке задачи оптимизации является **формализация (математическая запись) задачи**. На этом этапе все выявленные цели, переменные и ограничения переводятся в математическую модель, которая может быть решена с помощью соответствующих алгоритмов и методов оптимизации. Это включает в себя:

1.  Запись целевой функции в виде математического выражения.
2.  Определение области допустимых значений для переменных.
3.  Формулировка всех ограничений в виде уравнений или неравенств.


### 15. [Указан тег] в HTML позволяет задать

Без указания конкретного тега HTML невозможно дать точный ответ. Однако, HTML (HyperText Markup Language) использует теги для определения структуры и содержимого веб-страницы. Каждый тег имеет свое назначение. Например:

*   `<p>`: Задает абзац текста.
*   `<a>`: Создает гиперссылку.
*   `<img>`: Вставляет изображение.
*   `<div>`: Определяет логический раздел документа.
*   `<span>`: Определяет строчный элемент.
*   `<h1>` - `<h6>`: Задают заголовки различных уровней.
*   `<ul>`, `<ol>`, `<li>`: Создают неупорядоченные и упорядоченные списки, а также элементы списка.
*   `<form>`, `<input>`, `<button>`: Используются для создания форм и элементов управления.

Если бы был указан тег, например, `<img>`, ответ был бы: "Тег `<img>` в HTML позволяет задать изображение на веб-странице, указывая путь к файлу изображения, его альтернативный текст и другие атрибуты."

Пожалуйста, укажите тег для более точного ответа.


### 16. Какие алгоритмы могут применяться для шифрования?

Для шифрования могут применяться различные алгоритмы, которые делятся на две основные категории:

*   **Симметричные алгоритмы (шифрование с закрытым ключом)**: Используют один и тот же ключ как для шифрования, так и для расшифровки. Скорость шифрования высокая, но возникает проблема безопасного обмена ключами. Примеры:
    *   **AES (Advanced Encryption Standard)**: Современный, широко используемый и очень надежный алгоритм. Применяется в большинстве современных систем.
    *   **DES (Data Encryption Standard)**: Устаревший, но исторически важный алгоритм. Сейчас считается небезопасным из-за малой длины ключа.
    *   **3DES (Triple DES)**: Улучшенная версия DES, использующая DES трижды. Более безопасен, чем DES, но медленнее AES.
    *   **Blowfish, Twofish, RC4**.

*   **Асимметричные алгоритмы (шифрование с открытым ключом)**: Используют пару ключей — открытый (публичный) и закрытый (приватный). Открытый ключ может быть свободно распространен, а закрытый ключ хранится в секрете. Данные, зашифрованные открытым ключом, могут быть расшифрованы только соответствующим закрытым ключом, и наоборот. Используются для безопасного обмена ключами симметричного шифрования, цифровых подписей и аутентификации. Скорость шифрования ниже, чем у симметричных алгоритмов. Примеры:
    *   **RSA (Rivest–Shamir–Adleman)**: Один из первых и наиболее известных асимметричных алгоритмов. Широко используется для безопасной передачи данных и цифровых подписей.
    *   **ECC (Elliptic Curve Cryptography)**: Криптография на эллиптических кривых. Обеспечивает тот же уровень безопасности, что и RSA, но с меньшей длиной ключа, что делает его более эффективным для мобильных устройств и ограниченных ресурсов.
    *   **Diffie-Hellman**: Протокол обмена ключами, позволяющий двум сторонам установить общий секретный ключ по незащищенному каналу связи.

Выбор алгоритма зависит от конкретных требований к безопасности, производительности и сценария использования.


### 17. Что определяет лицо, принимающее решение?

Лицо, принимающее решение (ЛПР), определяет:

*   **Цели и задачи**: Что именно должно быть достигнуто в результате принятия решения.
*   **Критерии оценки**: По каким параметрам будет оцениваться эффективность и предпочтительность различных альтернатив.
*   **Альтернативы**: Какие варианты действий или решений доступны для выбора.
*   **Ограничения**: Какие факторы (ресурсы, время, правила, внешние условия) накладывают лимиты на возможные решения.
*   **Предпочтения**: Свои личные или организационные приоритеты и ценности, которые влияют на выбор наилучшей альтернативы.
*   **Риски и неопределенности**: Какие потенциальные негативные последствия могут возникнуть и какова степень их вероятности.

По сути, ЛПР определяет всю структуру и параметры задачи принятия решения.


### 18. Какой из протоколов является протоколом [заданного] уровня модели OSI?

Модель OSI (Open Systems Interconnection) состоит из семи уровней, каждый из которых выполняет определенные функции и использует соответствующие протоколы:

1.  **Физический уровень**: Определяет электрические, механические, процедурные и функциональные характеристики для активации, поддержания и деактивации физического соединения. Протоколы: Ethernet (физический аспект), USB, Bluetooth (физический аспект).
2.  **Канальный уровень**: Обеспечивает надежную передачу данных по физическому каналу, управляет доступом к среде передачи. Протоколы: Ethernet (MAC-адресация), PPP (Point-to-Point Protocol), HDLC (High-Level Data Link Control), Wi-Fi (802.11).
3.  **Сетевой уровень**: Обеспечивает логическую адресацию и маршрутизацию пакетов данных между различными сетями. Протоколы: IP (Internet Protocol), ICMP (Internet Control Message Protocol), ARP (Address Resolution Protocol), OSPF (Open Shortest Path First), RIP (Routing Information Protocol).
4.  **Транспортный уровень**: Обеспечивает сквозную передачу данных между конечными системами, сегментацию, контроль ошибок и потока. Протоколы: TCP (Transmission Control Protocol), UDP (User Datagram Protocol).
5.  **Сеансовый уровень**: Управляет сеансами связи между приложениями, устанавливает, поддерживает и завершает диалоги. Протоколы: NetBIOS, RPC (Remote Procedure Call), Sockets.
6.  **Представительский уровень**: Обеспечивает преобразование данных для представления приложениям, шифрование/дешифрование, сжатие/декомпрессия. Протоколы: JPEG, MPEG, ASCII, EBCDIC, SSL/TLS (частично).
7.  **Прикладной уровень**: Предоставляет сетевые службы для приложений конечных пользователей. Протоколы: HTTP (Hypertext Transfer Protocol), FTP (File Transfer Protocol), SMTP (Simple Mail Transfer Protocol), DNS (Domain Name System), Telnet, SSH (Secure Shell).

Для ответа на этот вопрос необходимо знать, какой именно уровень модели OSI указан в вопросе.


### 19. Укажите наименование блока данных [заданного] уровня модели OSI?

В модели OSI каждый уровень обрабатывает данные, полученные от вышестоящего уровня, добавляет к ним свою служебную информацию (заголовки и/или концевики) и передает получившийся блок данных нижестоящему уровню. Эти блоки данных имеют свои наименования:

*   **Прикладной, Представительский, Сеансовый уровни (7, 6, 5)**: Данные (Data). На этих уровнях данные обычно называются просто «данными» или «сообщением».
*   **Транспортный уровень (4)**: Сегмент (Segment) для TCP, Дейтаграмма (Datagram) для UDP.
*   **Сетевой уровень (3)**: Пакет (Packet) или Дейтаграмма (Datagram).
*   **Канальный уровень (2)**: Кадр (Frame).
*   **Физический уровень (1)**: Бит (Bit).

Для ответа на этот вопрос необходимо знать, какой именно уровень модели OSI указан в вопросе.


### 20. Что такое пассивная стратегия поиска при численном решении задач [задан вариант] оптимизации?

Пассивная стратегия поиска (или пассивный поиск) при численном решении задач оптимизации — это метод, при котором точки для вычисления целевой функции выбираются заранее, до начала процесса оптимизации, и не изменяются в зависимости от полученных результатов. То есть, процесс поиска не использует информацию о значениях целевой функции в уже вычисленных точках для определения следующих точек. Это контрастирует с активными стратегиями, где выбор следующей точки зависит от предыдущих вычислений.

Примеры пассивных стратегий:

*   **Равномерный поиск**: Точки распределяются равномерно по всему интервалу поиска.
*   **Случайный поиск**: Точки выбираются случайным образом.

Пассивные стратегии просты в реализации, но часто менее эффективны, чем активные, поскольку они не используют информацию о «ландшафте» целевой функции для более быстрого схождения к оптимуму. Они могут быть полезны для начального исследования функции или в случаях, когда вычисление функции очень дорого и нет возможности использовать более сложные методы.


### 21. Какая стратегия поиска наиболее часто применяется при численном решении задач [задан вариант] оптимизации?

При численном решении задач оптимизации наиболее часто применяются **активные (или адаптивные) стратегии поиска**. В отличие от пассивных, активные стратегии используют информацию о значениях целевой функции и/или ее производных в уже вычисленных точках для определения следующей точки поиска. Это позволяет алгоритму «адаптироваться» к форме целевой функции и более эффективно двигаться к оптимуму.

Примеры активных стратегий:

*   **Методы градиентного спуска (Gradient Descent)** и его модификации (стохастический градиентный спуск, Adam, RMSprop и т.д.): Используют градиент функции для определения направления наискорейшего спуска к минимуму. Широко применяются в машинном обучении.
*   **Методы Ньютона и квазиньютоновские методы (например, BFGS, L-BFGS)**: Используют информацию о второй производной (гессиане) или ее аппроксимации для более быстрого схождения.
*   **Методы прямого поиска (Direct Search Methods)**, которые не используют производные (например, метод Нелдера-Мида, метод Хука-Дживса, метод Розенброка): Применяются, когда производные недоступны или их вычисление затруднено.
*   **Генетические алгоритмы, алгоритмы роя частиц, имитация отжига** и другие метаэвристические алгоритмы: Используются для глобальной оптимизации, особенно в задачах с невыпуклыми или дискретными целевыми функциями.

Выбор конкретной стратегии зависит от свойств целевой функции (выпуклость, гладкость, наличие шума), наличия ограничений, размерности задачи и требуемой точности.


### 22. Принятие решения по [заданному] критерию …

В теории принятия решений существует множество критериев для выбора наилучшей альтернативы, особенно в условиях неопределенности или риска. Без указания конкретного критерия невозможно дать точный ответ. Однако, вот некоторые из наиболее распространенных критериев:

*   **Критерий Вальда (Wald's Criterion / Minimax Criterion)**: Применяется в условиях полной неопределенности. Выбирается альтернатива, которая максимизирует минимальный выигрыш (или минимизирует максимальный проигрыш). Это пессимистический критерий, ориентированный на наихудший сценарий.
*   **Критерий Сэвиджа (Savage's Criterion / Minimax Regret Criterion)**: Применяется в условиях неопределенности. Выбирается альтернатива, которая минимизирует максимальное сожаление (разницу между полученным результатом и наилучшим возможным результатом для данного состояния природы). Ориентирован на минимизацию упущенной выгоды.
*   **Критерий Лапласа (Laplace's Criterion / Principle of Insufficient Reason)**: Применяется в условиях неопределенности, когда вероятности состояний природы неизвестны. Предполагается, что все состояния природы равновероятны, и выбирается альтернатива с максимальным средним выигрышем.
*   **Критерий Гурвица (Hurwicz's Criterion)**: Компромиссный критерий между оптимизмом и пессимизмом. Использует коэффициент оптимизма (α) от 0 до 1. Выбирается альтернатива, которая максимизирует взвешенную сумму максимального и минимального выигрыша (α * max_выигрыш + (1-α) * min_выигрыш).
*   **Критерий Байеса (Bayes' Criterion)**: Применяется в условиях риска, когда известны вероятности состояний природы. Выбирается альтернатива с максимальным ожидаемым выигрышем (суммой произведений выигрышей на их вероятности).

Для ответа на этот вопрос необходимо знать, какой именно критерий указан в вопросе.


### 23. В чем отличия [заданного] критерия от [заданного] критерия?

Для ответа на этот вопрос необходимо знать, какие именно критерии сравниваются. Однако, основываясь на предыдущем вопросе, я могу привести пример сравнения двух критериев, например, критерия Вальда и критерия Сэвиджа, которые часто противопоставляются:

**Критерий Вальда (Wald's Criterion / Minimax Criterion)**:
*   **Суть**: Выбор альтернативы, которая максимизирует минимальный выигрыш (или минимизирует максимальный проигрыш) в наихудшем сценарии.
*   **Ориентация**: Крайний пессимизм. ЛПР предполагает, что природа будет действовать против него.
*   **Фокус**: Минимизация потерь в самом неблагоприятном случае.
*   **Применение**: Подходит для ситуаций, где ЛПР крайне не склонен к риску и хочет гарантировать себе минимально приемлемый результат, даже если это означает отказ от потенциально больших выигрышей.

**Критерий Сэвиджа (Savage's Criterion / Minimax Regret Criterion)**:
*   **Суть**: Выбор альтернативы, которая минимизирует максимальное сожаление (упущенную выгоду). Сожаление — это разница между результатом, который был получен, и результатом, который мог бы быть получен, если бы ЛПР знал, какое состояние природы наступит, и выбрал бы наилучшую альтернативу для этого состояния.
*   **Ориентация**: Минимизация разочарования от неправильного выбора.
*   **Фокус**: Минимизация разницы между фактическим результатом и идеальным результатом.
*   **Применение**: Подходит для ЛПР, которые хотят избежать ощущения «упущенной выгоды» и минимизировать потенциальное сожаление о своем выборе.

**Основные отличия:**
*   **Что минимизируется/максимизируется**: Вальд минимизирует максимальный проигрыш (или максимизирует минимальный выигрыш), Сэвидж минимизирует максимальное сожаление.
*   **Отношение к риску**: Вальд более пессимистичен и ориентирован на гарантированный результат. Сэвидж ориентирован на минимизацию упущенной выгоды, что может быть менее консервативным, чем Вальд.
*   **База для расчета**: Вальд оперирует непосредственно значениями выигрышей/проигрышей. Сэвидж оперирует матрицей сожалений, которая вычисляется на основе исходной матрицы выигрышей/проигрышей.

Для точного ответа, пожалуйста, укажите конкретные критерии для сравнения.


### 24. Имя функции, являющейся [продолжение вопроса] для программы на Си

Без полного контекста вопроса сложно дать точный ответ, но если речь идет о точке входа в программу на языке Си, то это функция с именем **`main`**. Программа на Си всегда начинает свое выполнение с функции `main()`.

Пример:
```c
int main() {
    // Код программы
    return 0;
}
```

Если вопрос подразумевает что-то другое (например, имя функции, которая является обработчиком прерывания, или имя функции, которая является частью какой-либо библиотеки), то ответ будет другим. Пожалуйста, уточните продолжение вопроса.


### 25. Что из перечисленного есть в стандартной библиотеке языка Си

Стандартная библиотека языка Си (Standard C Library) предоставляет набор функций, макросов и типов данных для выполнения общих задач, таких как ввод/вывод, работа со строками, математические операции, управление памятью и т.д. Она организована в виде заголовочных файлов. Вот некоторые из ключевых компонентов:

*   **`<stdio.h>`**: Функции для стандартного ввода/вывода (например, `printf`, `scanf`, `fopen`, `fclose`).
*   **`<stdlib.h>`**: Общие утилиты, включая функции для выделения/освобождения памяти (`malloc`, `free`), преобразования строк в числа (`atoi`, `atof`), генерации псевдослучайных чисел (`rand`, `srand`), завершения программы (`exit`).
*   **`<string.h>`**: Функции для работы со строками (например, `strcpy`, `strcat`, `strlen`, `strcmp`).
*   **`<math.h>`**: Математические функции (например, `sin`, `cos`, `sqrt`, `pow`, `log`).
*   **`<time.h>`**: Функции для работы со временем и датой (`time`, `difftime`, `strftime`).
*   **`<ctype.h>`**: Функции для проверки и преобразования символов (например, `isalpha`, `isdigit`, `tolower`, `toupper`).
*   **`<limits.h>`**: Определения диапазонов значений для целочисленных типов.
*   **`<float.h>`**: Определения диапазонов значений для типов с плавающей точкой.
*   **`<assert.h>`**: Макрос `assert` для отладки.
*   **`<stddef.h>`**: Определения общих типов и макросов (например, `size_t`, `NULL`).
*   **`<errno.h>`**: Для обработки ошибок.
*   **`<setjmp.h>`**: Для нелокальных переходов.
*   **`<signal.h>`**: Для обработки сигналов.
*   **`<stdarg.h>`**: Для работы с функциями с переменным числом аргументов.

Таким образом, в стандартной библиотеке Си есть множество базовых и часто используемых функций для системного программирования и общих вычислений.
